{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n/* eslint-disable @typescript-eslint/no-use-before-define */\nimport * as React from 'react';\nimport { noTextChildNodes, possibleStandardNames, randomString, styleToObject } from './helpers';\nfunction parseAttributes(node, reactKey) {\n  var attributes = {\n    key: reactKey\n  };\n  /* istanbul ignore else */\n  if (node instanceof Element) {\n    var nodeClassNames = node.getAttribute('class');\n    if (nodeClassNames) {\n      attributes.className = nodeClassNames;\n    }\n    __spreadArray([], __read(node.attributes), false).forEach(function (d) {\n      switch (d.name) {\n        // this is manually handled above, so break;\n        case 'class':\n          break;\n        case 'style':\n          attributes[d.name] = styleToObject(d.value);\n          break;\n        case 'allowfullscreen':\n        case 'allowpaymentrequest':\n        case 'async':\n        case 'autofocus':\n        case 'autoplay':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'defer':\n        case 'disabled':\n        case 'formnovalidate':\n        case 'hidden':\n        case 'ismap':\n        case 'itemscope':\n        case 'loop':\n        case 'multiple':\n        case 'muted':\n        case 'nomodule':\n        case 'novalidate':\n        case 'open':\n        case 'readonly':\n        case 'required':\n        case 'reversed':\n        case 'selected':\n        case 'typemustmatch':\n          attributes[possibleStandardNames[d.name] || d.name] = true;\n          break;\n        default:\n          attributes[possibleStandardNames[d.name] || d.name] = d.value;\n      }\n    });\n  }\n  return attributes;\n}\nfunction parseChildren(childNodeList, level, options) {\n  var children = __spreadArray([], __read(childNodeList), false).map(function (node, index) {\n    return convertFromNode(node, __assign(__assign({}, options), {\n      index: index,\n      level: level + 1\n    }));\n  }).filter(Boolean);\n  if (!children.length) {\n    return null;\n  }\n  return children;\n}\nfunction parseName(nodeName) {\n  if (/[a-z]+[A-Z]+[a-z]+/.test(nodeName)) {\n    return nodeName;\n  }\n  return nodeName.toLowerCase();\n}\nexport function convertFromNode(input, options) {\n  var _a;\n  if (options === void 0) {\n    options = {};\n  }\n  if (!input || !(input instanceof Node)) {\n    return null;\n  }\n  var _b = options.actions,\n    actions = _b === void 0 ? [] : _b,\n    _c = options.index,\n    index = _c === void 0 ? 0 : _c,\n    _d = options.level,\n    level = _d === void 0 ? 0 : _d,\n    randomKey = options.randomKey;\n  var node = input;\n  var key = \"\".concat(level, \"-\").concat(index);\n  var result = [];\n  if (randomKey && level === 0) {\n    key = \"\".concat(randomString(), \"-\").concat(key);\n  }\n  /* istanbul ignore else */\n  if (Array.isArray(actions)) {\n    actions.forEach(function (action) {\n      if (action.condition(node, key, level)) {\n        if (typeof action.pre === 'function') {\n          node = action.pre(node, key, level);\n          if (!(node instanceof Node)) {\n            node = input;\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n              // eslint-disable-next-line no-console\n              console.warn('The `pre` method always must return a valid DomNode (instanceof Node) - your modification will be ignored (Hint: if you want to render a React-component, use the `post` method instead)');\n            }\n          }\n        }\n        if (typeof action.post === 'function') {\n          result.push(action.post(node, key, level));\n        }\n      }\n    });\n  }\n  if (result.length) {\n    return result;\n  }\n  switch (node.nodeType) {\n    case 1:\n      {\n        // regular dom-node\n        return React.createElement(parseName(node.nodeName), parseAttributes(node, key), parseChildren(node.childNodes, level, options));\n      }\n    case 3:\n      {\n        // textnode\n        var nodeText = ((_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.toString()) || '';\n        /* istanbul ignore else */\n        if (/^\\s+$/.test(nodeText) && !/[\\u00A0\\u202F]/.test(nodeText)) {\n          return null;\n        }\n        /* istanbul ignore next */\n        if (!node.parentNode) {\n          return nodeText;\n        }\n        var parentNodeName = node.parentNode.nodeName.toLowerCase();\n        if (noTextChildNodes.includes(parentNodeName)) {\n          /* istanbul ignore else */\n          if (/\\S/.test(nodeText)) {\n            // eslint-disable-next-line no-console\n            console.warn(\"A textNode is not allowed inside '\".concat(parentNodeName, \"'. Your text \\\"\").concat(nodeText, \"\\\" will be ignored\"));\n          }\n          return null;\n        }\n        return nodeText;\n      }\n    case 8:\n      {\n        // html-comment\n        return null;\n      }\n    /* istanbul ignore next */\n    default:\n      {\n        return null;\n      }\n  }\n}\nexport function convertFromString(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (!input || typeof input !== 'string') {\n    return null;\n  }\n  var _a = options.nodeOnly,\n    nodeOnly = _a === void 0 ? false : _a,\n    _b = options.selector,\n    selector = _b === void 0 ? 'body > *' : _b,\n    _c = options.type,\n    type = _c === void 0 ? 'text/html' : _c;\n  try {\n    var parser = new DOMParser();\n    var document_1 = parser.parseFromString(input, type);\n    var node = document_1.querySelector(selector);\n    if (!(node instanceof Node)) {\n      throw new TypeError('Error parsing input');\n    }\n    if (nodeOnly) {\n      return node;\n    }\n    return convertFromNode(node, options);\n  } catch (error) {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n  return null;\n}\nexport default function convert(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  if (typeof input === 'string') {\n    return convertFromString(input, options);\n  }\n  if (input instanceof Node) {\n    return convertFromNode(input, options);\n  }\n  return null;\n}","map":{"version":3,"mappings":"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","names":["React","noTextChildNodes","possibleStandardNames","randomString","styleToObject","parseAttributes","node","reactKey","attributes","key","Element","nodeClassNames","getAttribute","className","__spreadArray","forEach","d","name","value","parseChildren","childNodeList","level","options","children","map","index","filter","Boolean","length","parseName","nodeName","test","toLowerCase","convertFromNode","input","Node","actions","_c","_d","randomKey","result","Array","isArray","action","condition","pre","process","env","NODE_ENV","console","warn","post","push","nodeType","createElement","childNodes","nodeText","nodeValue","toString","parentNode","parentNodeName","includes","convertFromString","nodeOnly","_b","selector","type","parser","DOMParser","document_1","parseFromString","querySelector","TypeError","error","convert"],"sources":["D:\\JavaScript\\ReactProjects\\markdownapp\\node_modules\\react-from-dom\\src\\index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport * as React from 'react';\n\nimport { noTextChildNodes, possibleStandardNames, randomString, styleToObject } from './helpers';\n\nexport interface Options {\n  actions?: Action[];\n  index?: number;\n  level?: number;\n  nodeOnly?: boolean;\n  randomKey?: boolean;\n  selector?: string;\n  type?: string;\n}\n\ninterface Attributes {\n  [index: string]: any;\n\n  key: string;\n}\n\nexport interface Action {\n  // If this returns true, the two following functions are called if they are defined\n  condition: (node: Node, key: string, level: number) => boolean;\n\n  // Use this to inject a component or remove the node\n  // It must return something that can be rendered by React\n  post?: (node: Node, key: string, level: number) => React.ReactNode;\n\n  // Use this to update or replace the node\n  // e.g. for removing or adding attributes, changing the node type\n  pre?: (node: Node, key: string, level: number) => Node;\n}\n\nfunction parseAttributes(node: Node, reactKey: string): Attributes {\n  const attributes: Attributes = {\n    key: reactKey,\n  };\n\n  /* istanbul ignore else */\n  if (node instanceof Element) {\n    const nodeClassNames = node.getAttribute('class');\n\n    if (nodeClassNames) {\n      attributes.className = nodeClassNames;\n    }\n\n    [...node.attributes].forEach(d => {\n      switch (d.name) {\n        // this is manually handled above, so break;\n        case 'class':\n          break;\n        case 'style':\n          attributes[d.name] = styleToObject(d.value);\n          break;\n        case 'allowfullscreen':\n        case 'allowpaymentrequest':\n        case 'async':\n        case 'autofocus':\n        case 'autoplay':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'defer':\n        case 'disabled':\n        case 'formnovalidate':\n        case 'hidden':\n        case 'ismap':\n        case 'itemscope':\n        case 'loop':\n        case 'multiple':\n        case 'muted':\n        case 'nomodule':\n        case 'novalidate':\n        case 'open':\n        case 'readonly':\n        case 'required':\n        case 'reversed':\n        case 'selected':\n        case 'typemustmatch':\n          attributes[possibleStandardNames[d.name] || d.name] = true;\n          break;\n        default:\n          attributes[possibleStandardNames[d.name] || d.name] = d.value;\n      }\n    });\n  }\n\n  return attributes;\n}\n\nfunction parseChildren(childNodeList: NodeList, level: number, options: Options) {\n  const children: React.ReactNode[] = [...childNodeList]\n    .map((node, index) =>\n      convertFromNode(node, {\n        ...options,\n        index,\n        level: level + 1,\n      }),\n    )\n    .filter(Boolean);\n\n  if (!children.length) {\n    return null;\n  }\n\n  return children;\n}\n\nfunction parseName(nodeName: string) {\n  if (/[a-z]+[A-Z]+[a-z]+/.test(nodeName)) {\n    return nodeName;\n  }\n\n  return nodeName.toLowerCase();\n}\n\nexport function convertFromNode(input: Node, options: Options = {}): React.ReactNode {\n  if (!input || !(input instanceof Node)) {\n    return null;\n  }\n\n  const { actions = [], index = 0, level = 0, randomKey } = options;\n\n  let node = input;\n  let key = `${level}-${index}`;\n  const result: React.ReactNode[] = [];\n\n  if (randomKey && level === 0) {\n    key = `${randomString()}-${key}`;\n  }\n\n  /* istanbul ignore else */\n  if (Array.isArray(actions)) {\n    actions.forEach((action: Action) => {\n      if (action.condition(node, key, level)) {\n        if (typeof action.pre === 'function') {\n          node = action.pre(node, key, level);\n\n          if (!(node instanceof Node)) {\n            node = input;\n\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n              // eslint-disable-next-line no-console\n              console.warn(\n                'The `pre` method always must return a valid DomNode (instanceof Node) - your modification will be ignored (Hint: if you want to render a React-component, use the `post` method instead)',\n              );\n            }\n          }\n        }\n\n        if (typeof action.post === 'function') {\n          result.push(action.post(node, key, level));\n        }\n      }\n    });\n  }\n\n  if (result.length) {\n    return result;\n  }\n\n  switch (node.nodeType) {\n    case 1: {\n      // regular dom-node\n      return React.createElement(\n        parseName(node.nodeName),\n        parseAttributes(node, key),\n        parseChildren(node.childNodes, level, options),\n      );\n    }\n    case 3: {\n      // textnode\n      const nodeText = node.nodeValue?.toString() || '';\n\n      /* istanbul ignore else */\n      if (/^\\s+$/.test(nodeText) && !/[\\u00A0\\u202F]/.test(nodeText)) {\n        return null;\n      }\n\n      /* istanbul ignore next */\n      if (!node.parentNode) {\n        return nodeText;\n      }\n\n      const parentNodeName = node.parentNode.nodeName.toLowerCase();\n\n      if (noTextChildNodes.includes(parentNodeName)) {\n        /* istanbul ignore else */\n        if (/\\S/.test(nodeText)) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `A textNode is not allowed inside '${parentNodeName}'. Your text \"${nodeText}\" will be ignored`,\n          );\n        }\n\n        return null;\n      }\n\n      return nodeText;\n    }\n    case 8: {\n      // html-comment\n      return null;\n    }\n    /* istanbul ignore next */\n    default: {\n      return null;\n    }\n  }\n}\n\nexport function convertFromString(input: string, options: Options = {}): React.ReactNode | Node {\n  if (!input || typeof input !== 'string') {\n    return null;\n  }\n\n  const { nodeOnly = false, selector = 'body > *', type = 'text/html' } = options;\n\n  try {\n    const parser = new DOMParser();\n    const document = parser.parseFromString(input, type as DOMParserSupportedType);\n    const node = document.querySelector(selector);\n\n    if (!(node instanceof Node)) {\n      throw new TypeError('Error parsing input');\n    }\n\n    if (nodeOnly) {\n      return node;\n    }\n\n    return convertFromNode(node, options);\n  } catch (error) {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      // eslint-disable-next-line no-console\n      console.error(error);\n    }\n  }\n\n  return null;\n}\n\nexport default function convert(\n  input: Node | string,\n  options: Options = {},\n): React.ReactNode | Node {\n  if (typeof input === 'string') {\n    return convertFromString(input, options);\n  }\n\n  if (input instanceof Node) {\n    return convertFromNode(input, options);\n  }\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}